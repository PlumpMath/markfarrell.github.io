<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Mark Farrell - The Loop Space of the Circle Is the Integers: Part 1</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>

        <div id="content">
            <h1><a href="../">Mark Farrell</a></h1>

            <h2>The Loop Space of the Circle Is the Integers: Part 1</h2>

            <div class="info">
    Posted on February 27, 2016
    
</div>

<p>I would like to expand on the discussion I started about homotopy type theory in one of my <a href="../posts/2016-02-18-what-is-homotopy-type-theory.html">previous posts</a>. Previously, I presented a rough outline of what the proof that the loop space of the circle is the integers would look like in a formal system for doing homotopy type theory. Now, I would like to how to make said proof precise. In this particular post, I would like to show how to construct the circle as a higher inductive data type and define functions from its loop space to the integers, and likewise a function from the integers to the loop space of the circle. I will leave the last main component of the proof, i.e. the construction of two logical homotopies showing that these functions are mutual inverses, for a follow-up post.</p>
<p>First and foremost, let’s precisely define the circle as a higher inductive data type. Recall that in the context of homotopy type theory, higher inductive data types are logical spaces (data types) that can be defined not only by constructors for their points, but also paths between their points, paths between theirs paths, and so on and so forth. Before we proceed to define the circle as a higher inductive data type, let’s try to gain some intuition for what higher inductive data types are, and how we might arrive at the definition of the circle.</p>
<p>Recall the definition of the booleans as an ordinary algebraic data type. In code, this looks like:</p>
<pre class="cubicaltt"><code>
data Boolean = True
             | False
</code></pre>
<p>Meanwhile, the booleans, viewed as a logical space with points inside of it, pictorially looks like:</p>
<p><img src="../images/boolean_space.png" width="30%" /></p>
<p>If we add a constructor for paths from <code>True</code> to <code>False</code>, we obtain a higher inductive data type known as the interval:</p>
<p><img src="../images/interval_space.png" width="30%" /></p>
<p>And, in code, the interval looks like:</p>
<pre class="cubicaltt"><code>
data Interval = True
              | False
              | AlongMeridian &lt;i&gt; [(i = 0) -&gt; True, (i = 1) -&gt; False]
</code></pre>
<p>We can just as well add another constructor for paths from <code>True</code> to <code>False</code>:</p>
<p><img src="../images/one_sphere.png" width="30%" /></p>
<p>In code, this looks like:</p>
<pre class="cubicaltt"><code>
data S1 = True
        | False
        | AlongNorth &lt;i&gt; [(i = 0) -&gt; True, (i = 1) -&gt; False]
        | AlongSouth &lt;i&gt; [(i = 0) -&gt; True, (i = 1) -&gt; False]
</code></pre>
<p>We’ve just described a one-dimensional sphere as a higher inductive data type. However, we can simplify our definition of the one-dimensional sphere, arriving at our definition of the logical circle, which pictorially looks like:</p>
<p><img src="../images/circle.png" width="30%" /></p>
<p>Finally, in code, our definition for the circle as a higher inductive data type looks like:</p>
<pre class="cubicaltt"><code>
data Circle = Base
            | Loop &lt;i&gt; [(i=0) -&gt; Base, (i=1) -&gt; Base]
</code></pre>
<p>Now, let’s define the integers as an ordinary algebraic data type, so that we can define our functions to and from the loop space of the circle and the integers. In code, our definition for the integers as an algebraic data type looks like:</p>
<pre class="cubicaltt"><code>
data Positive = One
              | Successor (n : Positive)

data Integer = Negative (n : Positive)
             | Zero
             | Positive (n : Positive)
</code></pre>
<pre class="cubicaltt"><code>
Helix (x : Circle) : Type = (CircleRecursion Type Integer SuccessorPath) x
</code></pre>
<p><em>I would like to give credit to Daniel Licata and Mike Shulman for their original <a href="http://dlicata.web.wesleyan.edu/pubs/ls13pi1s1/ls13pi1s1.pdf">type-theoretic proof</a> that the first homotopy group of the circle is the integers. I would also like to give credit to Thierry Coquand for his contribution of a more recent <a href="https://github.com/markfarrell/cubicaltt/blob/master/experiments/helix.ctt">proof</a> to the cubical type theory project. My personal notes on the matter use ideas from these works.</em></p>


        </div>
    </body>
</html>
